<!DOCTYPE html>
<html>
	<head>

		<meta charset="utf-8">
		<title>duck.js</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script type="module">
			import * as THREE from 'https://cdn.skypack.dev/three@0.134.0';
			import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/loaders/GLTFLoader';
			import { RGBELoader } from "https://cdn.skypack.dev/three@0.134.0/examples/jsm/loaders/RGBELoader"
			import { OrbitControls } from "https://cdn.skypack.dev/three@0.134.0/examples/jsm/controls/OrbitControls"
			// import { TextGeometry } from "https://cdn.skypack.dev/three@0.134.0/examples/jsm/geometries/TextGeometry"

			let camera, scene, renderer, duck, text, i = 1, direction= 1, pointLight;

			init();
			render();

			function init() {

				const container = document.createElement('div');
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 90, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.x = 4;
				camera.position.z = 5;
				camera.position.y = 3;

				scene = new THREE.Scene();

				pointLight = new THREE.PointLight(0xffffff, 1.5); pointLight.position.set(0, 100, 90);
				scene.add(pointLight);
				// new FontLoader()
				// 	.load(
					
				// )
				// text = new THREE.TextGeometry("test", {
				// 	font: "Comic Sans"
				// })


				// new RGBELoader()
				// 	.load( '/background', function ( texture ) {

				// 		texture.mapping = THREE.EquirectangularReflectionMapping;

				// 		scene.background = texture;
				// 		scene.environment = texture;

				// 		render();

				// 		// model

				// 		const loader = new GLTFLoader();

				// 		loader.load( 'duck/scene.glb', function ( gltf ) {

				// 			scene.add( gltf.scene );

				// 			render();

				// 			duck = gltf.scene;

				// 			window.requestAnimationFrame(duckRotate)

				// 		}, undefined, function ( error ) {

				// 			console.error( error );

				// 		} );

				// 	});

				const loader = new GLTFLoader();

				loader.load( 'duck/scene.glb', function ( gltf ) {

					scene.add( gltf.scene );

					render();

					duck = gltf.scene;

					window.requestAnimationFrame(duckRotate)

				}, undefined, function ( error ) {

					console.error( error );

				} );

				window.requestAnimationFrame(rave)

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.outputEncoding = THREE.sRGBEncoding;
				container.appendChild( renderer.domElement );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render ); // use if there is no animation loop
				controls.minDistance = 2;
				controls.maxDistance = 15;
				controls.target.set( 0, 0, - 0.2 );
				controls.update();

				window.addEventListener( 'resize', onWindowResize );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);

				render();
			}

			function render() {


				renderer.render( scene, camera );
			}

			function duckRotate() {
				if (duck) {
					duck.rotation.y += 0.05;
					render()
				}

				window.requestAnimationFrame(duckRotate)
			}

			function rave () {
				console.log(pointLight)
				i++;
				if (i >= 255) {
					direction *= -1;
					i = 255;
				};
				if (i < 0) {
					direction *= -1;
					i = 0;
				}
				pointLight.color = new THREE.Color(`hsl(${i},100%,50%)`);

				i += direction;
				// pointLight.intensity = 8;

				window.requestAnimationFrame(rave)
			}
			

		</script>
	</body>
</html>